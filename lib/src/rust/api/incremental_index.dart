// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `cosine_distance`, `new`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BufferEntry`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Add a single vector to the index immediately (incremental)
///
/// The vector is added to the buffer and becomes searchable immediately.
/// When buffer reaches threshold, triggers background merge to HNSW.
Future<void> incrementalAdd({
  required PlatformInt64 docId,
  required List<double> embedding,
}) => RustLib.instance.api.crateApiIncrementalIndexIncrementalAdd(
  docId: docId,
  embedding: embedding,
);

/// Add multiple vectors to index (batch incremental)
Future<void> incrementalAddBatch({
  required List<(PlatformInt64, Float32List)> docs,
}) => RustLib.instance.api.crateApiIncrementalIndexIncrementalAddBatch(
  docs: docs,
);

/// Remove a document from the index
///
/// Note: Removes from buffer immediately, but HNSW removal requires rebuild
Future<void> incrementalRemove({required PlatformInt64 docId}) => RustLib
    .instance
    .api
    .crateApiIncrementalIndexIncrementalRemove(docId: docId);

/// Search the incremental index (both buffer and HNSW)
///
/// Combines results from:
/// 1. Linear scan of buffer (for recently added docs)
/// 2. HNSW search (for pre-indexed docs)
Future<List<IncrementalSearchResult>> incrementalSearch({
  required List<double> queryEmbedding,
  required BigInt topK,
}) => RustLib.instance.api.crateApiIncrementalIndexIncrementalSearch(
  queryEmbedding: queryEmbedding,
  topK: topK,
);

Future<BufferStats> getBufferStats() =>
    RustLib.instance.api.crateApiIncrementalIndexGetBufferStats();

/// Clear the buffer (useful after manual HNSW rebuild)
Future<void> clearBuffer() =>
    RustLib.instance.api.crateApiIncrementalIndexClearBuffer();

/// Check if buffer needs merging
Future<bool> needsMerge() =>
    RustLib.instance.api.crateApiIncrementalIndexNeedsMerge();

/// Get all buffer entries for HNSW rebuild
///
/// Returns (doc_id, embedding) pairs to be combined with DB data for rebuild
Future<List<(PlatformInt64, Float32List)>> getBufferForMerge() =>
    RustLib.instance.api.crateApiIncrementalIndexGetBufferForMerge();

/// Get buffer statistics
class BufferStats {
  final BigInt bufferSize;
  final BigInt threshold;
  final bool hnswLoaded;

  const BufferStats({
    required this.bufferSize,
    required this.threshold,
    required this.hnswLoaded,
  });

  @override
  int get hashCode =>
      bufferSize.hashCode ^ threshold.hashCode ^ hnswLoaded.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BufferStats &&
          runtimeType == other.runtimeType &&
          bufferSize == other.bufferSize &&
          threshold == other.threshold &&
          hnswLoaded == other.hnswLoaded;
}

/// Search result from incremental index
class IncrementalSearchResult {
  final PlatformInt64 docId;
  final double distance;

  /// Source: 'buffer' or 'hnsw'
  final String source;

  const IncrementalSearchResult({
    required this.docId,
    required this.distance,
    required this.source,
  });

  @override
  int get hashCode => docId.hashCode ^ distance.hashCode ^ source.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is IncrementalSearchResult &&
          runtimeType == other.runtimeType &&
          docId == other.docId &&
          distance == other.distance &&
          source == other.source;
}
