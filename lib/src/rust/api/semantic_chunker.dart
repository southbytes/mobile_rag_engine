// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `is_article_title`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `eq`, `fmt`, `fmt`

/// Classify chunk by rule-based pattern matching.
ChunkType classifyChunk({required String text}) =>
    RustLib.instance.api.crateApiSemanticChunkerClassifyChunk(text: text);

/// Split text into semantic chunks using paragraph-first strategy.
List<SemanticChunk> semanticChunk({
  required String text,
  required int maxChars,
}) => RustLib.instance.api.crateApiSemanticChunkerSemanticChunk(
  text: text,
  maxChars: maxChars,
);

/// Split text with overlap (API compatibility wrapper).
List<SemanticChunk> semanticChunkWithOverlap({
  required String text,
  required int maxChars,
  required int overlapChars,
}) => RustLib.instance.api.crateApiSemanticChunkerSemanticChunkWithOverlap(
  text: text,
  maxChars: maxChars,
  overlapChars: overlapChars,
);

/// Chunk type classification.
enum ChunkType {
  definition,
  example,
  list,
  procedure,
  comparison,
  general;

  Future<void> asStr() =>
      RustLib.instance.api.crateApiSemanticChunkerChunkTypeAsStr(that: this);

  static Future<ChunkType> fromStr({required String s}) =>
      RustLib.instance.api.crateApiSemanticChunkerChunkTypeFromStr(s: s);
}

/// Semantic chunk result.
class SemanticChunk {
  final int index;
  final String content;
  final int startPos;
  final int endPos;
  final String chunkType;

  const SemanticChunk({
    required this.index,
    required this.content,
    required this.startPos,
    required this.endPos,
    required this.chunkType,
  });

  @override
  int get hashCode =>
      index.hashCode ^
      content.hashCode ^
      startPos.hashCode ^
      endPos.hashCode ^
      chunkType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SemanticChunk &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          content == other.content &&
          startPos == other.startPos &&
          endPos == other.endPos &&
          chunkType == other.chunkType;
}
