// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `is_article_title`, `protect_structural_blocks`, `recursive_split`, `split_by_headers`, `split_by_lines`, `split_by_sentences`, `split_table_preserving_headers`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ChunkingStrategy`, `ProtectedText`, `Section`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`

/// Classify chunk by rule-based pattern matching.
ChunkType classifyChunk({required String text}) =>
    RustLib.instance.api.crateApiSemanticChunkerClassifyChunk(text: text);

/// Split text into semantic chunks using paragraph-first strategy.
List<SemanticChunk> semanticChunk({
  required String text,
  required int maxChars,
}) => RustLib.instance.api.crateApiSemanticChunkerSemanticChunk(
  text: text,
  maxChars: maxChars,
);

/// Split text with overlap (API compatibility wrapper).
List<SemanticChunk> semanticChunkWithOverlap({
  required String text,
  required int maxChars,
  required int overlapChars,
}) => RustLib.instance.api.crateApiSemanticChunkerSemanticChunkWithOverlap(
  text: text,
  maxChars: maxChars,
  overlapChars: overlapChars,
);

/// Markdown chunk with structure preservation and metadata inheritance.
///
/// - Splits by Markdown headers (#, ##, ###)
/// - Preserves code blocks (```) as single units
/// - Preserves tables (|---|) as single units
/// - Inherits header path as metadata
List<StructuredChunk> markdownChunk({
  required String text,
  required int maxChars,
}) => RustLib.instance.api.crateApiSemanticChunkerMarkdownChunk(
  text: text,
  maxChars: maxChars,
);

/// Chunk type classification.
enum ChunkType {
  definition,
  example,
  list,
  procedure,
  comparison,
  general;

  Future<void> asStr() =>
      RustLib.instance.api.crateApiSemanticChunkerChunkTypeAsStr(that: this);

  static Future<ChunkType> fromStr({required String s}) =>
      RustLib.instance.api.crateApiSemanticChunkerChunkTypeFromStr(s: s);
}

/// Semantic chunk result.
class SemanticChunk {
  final int index;
  final String content;
  final int startPos;
  final int endPos;
  final String chunkType;

  const SemanticChunk({
    required this.index,
    required this.content,
    required this.startPos,
    required this.endPos,
    required this.chunkType,
  });

  @override
  int get hashCode =>
      index.hashCode ^
      content.hashCode ^
      startPos.hashCode ^
      endPos.hashCode ^
      chunkType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SemanticChunk &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          content == other.content &&
          startPos == other.startPos &&
          endPos == other.endPos &&
          chunkType == other.chunkType;
}

/// Structured chunk with header path for context inheritance.
class StructuredChunk {
  final int index;
  final String content;
  final String headerPath;
  final String chunkType;
  final int startPos;
  final int endPos;
  final Map<String, String> metadata;

  const StructuredChunk({
    required this.index,
    required this.content,
    required this.headerPath,
    required this.chunkType,
    required this.startPos,
    required this.endPos,
    required this.metadata,
  });

  @override
  int get hashCode =>
      index.hashCode ^
      content.hashCode ^
      headerPath.hashCode ^
      chunkType.hashCode ^
      startPos.hashCode ^
      endPos.hashCode ^
      metadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StructuredChunk &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          content == other.content &&
          headerPath == other.headerPath &&
          chunkType == other.chunkType &&
          startPos == other.startPos &&
          endPos == other.endPos &&
          metadata == other.metadata;
}
