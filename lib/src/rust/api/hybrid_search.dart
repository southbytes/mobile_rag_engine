// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `rrf_score`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Perform hybrid search combining vector and keyword search.
Future<List<HybridSearchResult>> searchHybrid({
  required String queryText,
  required List<double> queryEmbedding,
  required int topK,
  RrfConfig? config,
  SearchFilter? filter,
}) => RustLib.instance.api.crateApiHybridSearchSearchHybrid(
  queryText: queryText,
  queryEmbedding: queryEmbedding,
  topK: topK,
  config: config,
  filter: filter,
);

/// Simplified hybrid search returning content strings only.
Future<List<String>> searchHybridSimple({
  required String queryText,
  required List<double> queryEmbedding,
  required int topK,
}) => RustLib.instance.api.crateApiHybridSearchSearchHybridSimple(
  queryText: queryText,
  queryEmbedding: queryEmbedding,
  topK: topK,
);

/// Search with custom weights (vector_weight + bm25_weight = 1.0 recommended).
Future<List<HybridSearchResult>> searchHybridWeighted({
  required String queryText,
  required List<double> queryEmbedding,
  required int topK,
  required double vectorWeight,
  required double bm25Weight,
}) => RustLib.instance.api.crateApiHybridSearchSearchHybridWeighted(
  queryText: queryText,
  queryEmbedding: queryEmbedding,
  topK: topK,
  vectorWeight: vectorWeight,
  bm25Weight: bm25Weight,
);

class HybridSearchResult {
  final PlatformInt64 docId;
  final String content;
  final double score;
  final int vectorRank;
  final int bm25Rank;
  final PlatformInt64 sourceId;
  final String? metadata;
  final int chunkIndex;

  const HybridSearchResult({
    required this.docId,
    required this.content,
    required this.score,
    required this.vectorRank,
    required this.bm25Rank,
    required this.sourceId,
    this.metadata,
    required this.chunkIndex,
  });

  @override
  int get hashCode =>
      docId.hashCode ^
      content.hashCode ^
      score.hashCode ^
      vectorRank.hashCode ^
      bm25Rank.hashCode ^
      sourceId.hashCode ^
      metadata.hashCode ^
      chunkIndex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is HybridSearchResult &&
          runtimeType == other.runtimeType &&
          docId == other.docId &&
          content == other.content &&
          score == other.score &&
          vectorRank == other.vectorRank &&
          bm25Rank == other.bm25Rank &&
          sourceId == other.sourceId &&
          metadata == other.metadata &&
          chunkIndex == other.chunkIndex;
}

class RrfConfig {
  final int k;
  final double vectorWeight;
  final double bm25Weight;

  const RrfConfig({
    required this.k,
    required this.vectorWeight,
    required this.bm25Weight,
  });

  static Future<RrfConfig> default_() =>
      RustLib.instance.api.crateApiHybridSearchRrfConfigDefault();

  @override
  int get hashCode => k.hashCode ^ vectorWeight.hashCode ^ bm25Weight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RrfConfig &&
          runtimeType == other.runtimeType &&
          k == other.k &&
          vectorWeight == other.vectorWeight &&
          bm25Weight == other.bm25Weight;
}

class SearchFilter {
  final Int64List? sourceIds;
  final String? metadataLike;

  const SearchFilter({this.sourceIds, this.metadataLike});

  @override
  int get hashCode => sourceIds.hashCode ^ metadataLike.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SearchFilter &&
          runtimeType == other.runtimeType &&
          sourceIds == other.sourceIds &&
          metadataLike == other.metadataLike;
}
