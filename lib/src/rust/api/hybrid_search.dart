// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `rrf_score`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`

/// Perform hybrid search combining vector and keyword search
///
/// # Arguments
/// * `db_path` - Path to SQLite database
/// * `query_text` - Original query text for BM25
/// * `query_embedding` - Query embedding for vector search
/// * `top_k` - Number of results to return
/// * `config` - RRF configuration (optional, uses default if None)
Future<List<HybridSearchResult>> searchHybrid({
  required String dbPath,
  required String queryText,
  required List<double> queryEmbedding,
  required int topK,
  RrfConfig? config,
}) => RustLib.instance.api.crateApiHybridSearchSearchHybrid(
  dbPath: dbPath,
  queryText: queryText,
  queryEmbedding: queryEmbedding,
  topK: topK,
  config: config,
);

/// Simplified hybrid search that returns only content strings
/// Compatible with existing search_similar API
Future<List<String>> searchHybridSimple({
  required String dbPath,
  required String queryText,
  required List<double> queryEmbedding,
  required int topK,
}) => RustLib.instance.api.crateApiHybridSearchSearchHybridSimple(
  dbPath: dbPath,
  queryText: queryText,
  queryEmbedding: queryEmbedding,
  topK: topK,
);

/// Search with custom weights
///
/// # Arguments
/// * `vector_weight` - Weight for vector search (0.0 - 1.0)
/// * `bm25_weight` - Weight for BM25 search (0.0 - 1.0)
///
/// # Example
/// - Pure vector search: vector_weight=1.0, bm25_weight=0.0
/// - Balanced: vector_weight=0.5, bm25_weight=0.5
/// - Keyword-heavy: vector_weight=0.3, bm25_weight=0.7
Future<List<HybridSearchResult>> searchHybridWeighted({
  required String dbPath,
  required String queryText,
  required List<double> queryEmbedding,
  required int topK,
  required double vectorWeight,
  required double bm25Weight,
}) => RustLib.instance.api.crateApiHybridSearchSearchHybridWeighted(
  dbPath: dbPath,
  queryText: queryText,
  queryEmbedding: queryEmbedding,
  topK: topK,
  vectorWeight: vectorWeight,
  bm25Weight: bm25Weight,
);

/// Hybrid search result with combined ranking
class HybridSearchResult {
  /// Document ID
  final PlatformInt64 docId;

  /// Document content
  final String content;

  /// Combined RRF score
  final double score;

  /// Original vector search rank (0 if not found)
  final int vectorRank;

  /// Original BM25 rank (0 if not found)
  final int bm25Rank;

  const HybridSearchResult({
    required this.docId,
    required this.content,
    required this.score,
    required this.vectorRank,
    required this.bm25Rank,
  });

  @override
  int get hashCode =>
      docId.hashCode ^
      content.hashCode ^
      score.hashCode ^
      vectorRank.hashCode ^
      bm25Rank.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is HybridSearchResult &&
          runtimeType == other.runtimeType &&
          docId == other.docId &&
          content == other.content &&
          score == other.score &&
          vectorRank == other.vectorRank &&
          bm25Rank == other.bm25Rank;
}

/// Reciprocal Rank Fusion parameters
class RrfConfig {
  /// RRF constant k (default: 60, higher = more smoothing)
  final int k;

  /// Weight for vector search (0.0 - 1.0)
  final double vectorWeight;

  /// Weight for BM25 search (0.0 - 1.0)
  final double bm25Weight;

  const RrfConfig({
    required this.k,
    required this.vectorWeight,
    required this.bm25Weight,
  });

  static Future<RrfConfig> default_() =>
      RustLib.instance.api.crateApiHybridSearchRrfConfigDefault();

  @override
  int get hashCode => k.hashCode ^ vectorWeight.hashCode ^ bm25Weight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RrfConfig &&
          runtimeType == other.runtimeType &&
          k == other.k &&
          vectorWeight == other.vectorWeight &&
          bm25Weight == other.bm25Weight;
}
