// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


            // These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`


            /// Split text into sentences using Unicode-aware boundaries.
/// Supports Korean (sentence-ending patterns) and English (period, ?, !).
Future<List<String>>  splitSentences({required String text }) => RustLib.instance.api.crateApiCompressionUtilsSplitSentences(text: text);

/// Calculate a fast hash for sentence deduplication.
/// Uses a simple but effective string hash.
Future<BigInt>  sentenceHash({required String sentence }) => RustLib.instance.api.crateApiCompressionUtilsSentenceHash(sentence: sentence);

/// Compress text using the full pipeline.
///
/// # Arguments
/// * `text` - Text to compress
/// * `max_chars` - Maximum characters in result (0 = no limit)
/// * `options` - Compression options
Future<CompressedText>  compressText({required String text , required int maxChars , required CompressionOptions options }) => RustLib.instance.api.crateApiCompressionUtilsCompressText(text: text, maxChars: maxChars, options: options);

/// Quick compress with default options.
Future<String>  compressTextSimple({required String text , required int level }) => RustLib.instance.api.crateApiCompressionUtilsCompressTextSimple(text: text, level: level);

/// Check if text needs compression based on token estimate.
/// Returns true if estimated tokens exceed threshold.
Future<bool>  shouldCompress({required String text , required int tokenThreshold }) => RustLib.instance.api.crateApiCompressionUtilsShouldCompress(text: text, tokenThreshold: tokenThreshold);

            /// Result of text compression
class CompressedText  {
                /// Compressed text content
final String text;
/// Original character count
final int originalChars;
/// Compressed character count
final int compressedChars;
/// Compression ratio (0.0 - 1.0, lower = more compressed)
final double ratio;
/// Number of duplicate sentences removed
final int sentencesRemoved;
/// Characters saved by stopword removal
final int charsSavedStopwords;
/// Characters saved by truncation
final int charsSavedTruncation;

                const CompressedText({required this.text ,required this.originalChars ,required this.compressedChars ,required this.ratio ,required this.sentencesRemoved ,required this.charsSavedStopwords ,required this.charsSavedTruncation ,});

                
                

                
        @override
        int get hashCode => text.hashCode^originalChars.hashCode^compressedChars.hashCode^ratio.hashCode^sentencesRemoved.hashCode^charsSavedStopwords.hashCode^charsSavedTruncation.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is CompressedText &&
                runtimeType == other.runtimeType
                && text == other.text&& originalChars == other.originalChars&& compressedChars == other.compressedChars&& ratio == other.ratio&& sentencesRemoved == other.sentencesRemoved&& charsSavedStopwords == other.charsSavedStopwords&& charsSavedTruncation == other.charsSavedTruncation;
        
            }

/// Compression options
class CompressionOptions  {
                /// Remove stopwords (common words with low information value)
final bool removeStopwords;
/// Remove duplicate sentences
final bool removeDuplicates;
/// Language for stopword filtering ("ko" or "en")
final String language;
/// Compression level: 0=minimal, 1=balanced, 2=aggressive
final int level;

                const CompressionOptions({required this.removeStopwords ,required this.removeDuplicates ,required this.language ,required this.level ,});

                static Future<CompressionOptions>  default_()=>RustLib.instance.api.crateApiCompressionUtilsCompressionOptionsDefault();


                

                
        @override
        int get hashCode => removeStopwords.hashCode^removeDuplicates.hashCode^language.hashCode^level.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is CompressionOptions &&
                runtimeType == other.runtimeType
                && removeStopwords == other.removeStopwords&& removeDuplicates == other.removeDuplicates&& language == other.language&& level == other.level;
        
            }
            