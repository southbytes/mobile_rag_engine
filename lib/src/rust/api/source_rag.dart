// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `hash_content`, `search_chunks_linear`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`

/// Initialize extended database with sources and chunks tables.
Future<void> initSourceDb({required String dbPath}) =>
    RustLib.instance.api.crateApiSourceRagInitSourceDb(dbPath: dbPath);

/// Add a source document (without chunks - chunks added separately).
Future<AddSourceResult> addSource({
  required String dbPath,
  required String content,
  String? metadata,
}) => RustLib.instance.api.crateApiSourceRagAddSource(
  dbPath: dbPath,
  content: content,
  metadata: metadata,
);

/// Add chunks for a source document.
/// Uses transaction for atomicity - all chunks are saved or none.
Future<int> addChunks({
  required String dbPath,
  required PlatformInt64 sourceId,
  required List<ChunkData> chunks,
}) => RustLib.instance.api.crateApiSourceRagAddChunks(
  dbPath: dbPath,
  sourceId: sourceId,
  chunks: chunks,
);

/// Rebuild HNSW index from chunks table.
Future<void> rebuildChunkHnswIndex({required String dbPath}) =>
    RustLib.instance.api.crateApiSourceRagRebuildChunkHnswIndex(dbPath: dbPath);

/// Search chunks by embedding similarity.
Future<List<ChunkSearchResult>> searchChunks({
  required String dbPath,
  required List<double> queryEmbedding,
  required int topK,
}) => RustLib.instance.api.crateApiSourceRagSearchChunks(
  dbPath: dbPath,
  queryEmbedding: queryEmbedding,
  topK: topK,
);

/// Get source document by ID.
Future<String?> getSource({
  required String dbPath,
  required PlatformInt64 sourceId,
}) => RustLib.instance.api.crateApiSourceRagGetSource(
  dbPath: dbPath,
  sourceId: sourceId,
);

/// Get all chunks for a source.
Future<List<String>> getSourceChunks({
  required String dbPath,
  required PlatformInt64 sourceId,
}) => RustLib.instance.api.crateApiSourceRagGetSourceChunks(
  dbPath: dbPath,
  sourceId: sourceId,
);

/// Delete a source and all its chunks.
Future<void> deleteSource({
  required String dbPath,
  required PlatformInt64 sourceId,
}) => RustLib.instance.api.crateApiSourceRagDeleteSource(
  dbPath: dbPath,
  sourceId: sourceId,
);

Future<SourceStats> getSourceStats({required String dbPath}) =>
    RustLib.instance.api.crateApiSourceRagGetSourceStats(dbPath: dbPath);

/// Result of adding a source document.
class AddSourceResult {
  final PlatformInt64 sourceId;
  final bool isDuplicate;
  final int chunkCount;
  final String message;

  const AddSourceResult({
    required this.sourceId,
    required this.isDuplicate,
    required this.chunkCount,
    required this.message,
  });

  @override
  int get hashCode =>
      sourceId.hashCode ^
      isDuplicate.hashCode ^
      chunkCount.hashCode ^
      message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddSourceResult &&
          runtimeType == other.runtimeType &&
          sourceId == other.sourceId &&
          isDuplicate == other.isDuplicate &&
          chunkCount == other.chunkCount &&
          message == other.message;
}

/// Chunk data for batch insertion.
class ChunkData {
  final String content;
  final int chunkIndex;
  final int startPos;
  final int endPos;
  final Float32List embedding;

  const ChunkData({
    required this.content,
    required this.chunkIndex,
    required this.startPos,
    required this.endPos,
    required this.embedding,
  });

  @override
  int get hashCode =>
      content.hashCode ^
      chunkIndex.hashCode ^
      startPos.hashCode ^
      endPos.hashCode ^
      embedding.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChunkData &&
          runtimeType == other.runtimeType &&
          content == other.content &&
          chunkIndex == other.chunkIndex &&
          startPos == other.startPos &&
          endPos == other.endPos &&
          embedding == other.embedding;
}

/// Search result with chunk and source info.
class ChunkSearchResult {
  final PlatformInt64 chunkId;
  final PlatformInt64 sourceId;
  final int chunkIndex;
  final String content;
  final double similarity;

  const ChunkSearchResult({
    required this.chunkId,
    required this.sourceId,
    required this.chunkIndex,
    required this.content,
    required this.similarity,
  });

  @override
  int get hashCode =>
      chunkId.hashCode ^
      sourceId.hashCode ^
      chunkIndex.hashCode ^
      content.hashCode ^
      similarity.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChunkSearchResult &&
          runtimeType == other.runtimeType &&
          chunkId == other.chunkId &&
          sourceId == other.sourceId &&
          chunkIndex == other.chunkIndex &&
          content == other.content &&
          similarity == other.similarity;
}

/// Get count of sources and chunks.
class SourceStats {
  final PlatformInt64 sourceCount;
  final PlatformInt64 chunkCount;

  const SourceStats({required this.sourceCount, required this.chunkCount});

  @override
  int get hashCode => sourceCount.hashCode ^ chunkCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SourceStats &&
          runtimeType == other.runtimeType &&
          sourceCount == other.sourceCount &&
          chunkCount == other.chunkCount;
}
