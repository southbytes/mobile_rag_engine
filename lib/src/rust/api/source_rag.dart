// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `hash_content`, `search_chunks_linear`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Initialize database with sources and chunks tables.
Future<void> initSourceDb() =>
    RustLib.instance.api.crateApiSourceRagInitSourceDb();

/// Add a source document (chunks added separately via add_chunks).
Future<AddSourceResult> addSource({
  required String content,
  String? metadata,
  String? name,
}) => RustLib.instance.api.crateApiSourceRagAddSource(
  content: content,
  metadata: metadata,
  name: name,
);

/// Update processing status of a source (e.g., 'pending', 'processing', 'completed', 'failed').
Future<void> updateSourceStatus({
  required PlatformInt64 sourceId,
  required String status,
}) => RustLib.instance.api.crateApiSourceRagUpdateSourceStatus(
  sourceId: sourceId,
  status: status,
);

Future<List<SourceEntry>> listSources() =>
    RustLib.instance.api.crateApiSourceRagListSources();

/// Add chunks for a source (uses transaction for atomicity).
Future<int> addChunks({
  required PlatformInt64 sourceId,
  required List<ChunkData> chunks,
}) => RustLib.instance.api.crateApiSourceRagAddChunks(
  sourceId: sourceId,
  chunks: chunks,
);

/// Rebuild HNSW index from chunks table.
Future<void> rebuildChunkHnswIndex() =>
    RustLib.instance.api.crateApiSourceRagRebuildChunkHnswIndex();

/// Rebuild BM25 index from chunks table.
Future<void> rebuildChunkBm25Index() =>
    RustLib.instance.api.crateApiSourceRagRebuildChunkBm25Index();

/// Check if BM25 index is loaded for chunks.
Future<bool> isChunkBm25IndexLoaded() =>
    RustLib.instance.api.crateApiSourceRagIsChunkBm25IndexLoaded();

/// Search chunks by embedding similarity.
Future<List<ChunkSearchResult>> searchChunks({
  required List<double> queryEmbedding,
  required int topK,
}) => RustLib.instance.api.crateApiSourceRagSearchChunks(
  queryEmbedding: queryEmbedding,
  topK: topK,
);

/// Get source document by ID.
Future<String?> getSource({required PlatformInt64 sourceId}) =>
    RustLib.instance.api.crateApiSourceRagGetSource(sourceId: sourceId);

/// Get all chunks for a source.
Future<List<String>> getSourceChunks({required PlatformInt64 sourceId}) =>
    RustLib.instance.api.crateApiSourceRagGetSourceChunks(sourceId: sourceId);

/// Get adjacent chunks by source_id and chunk_index range.
Future<List<ChunkSearchResult>> getAdjacentChunks({
  required PlatformInt64 sourceId,
  required int minIndex,
  required int maxIndex,
}) => RustLib.instance.api.crateApiSourceRagGetAdjacentChunks(
  sourceId: sourceId,
  minIndex: minIndex,
  maxIndex: maxIndex,
);

/// Delete a source and all its chunks.
Future<void> deleteSource({required PlatformInt64 sourceId}) =>
    RustLib.instance.api.crateApiSourceRagDeleteSource(sourceId: sourceId);

/// Get the number of chunks for a specific source.
Future<int> getSourceChunkCount({required PlatformInt64 sourceId}) => RustLib
    .instance
    .api
    .crateApiSourceRagGetSourceChunkCount(sourceId: sourceId);

Future<SourceStats> getSourceStats() =>
    RustLib.instance.api.crateApiSourceRagGetSourceStats();

/// Get all chunk IDs and contents for re-embedding.
Future<List<ChunkForReembedding>> getAllChunkIdsAndContents() =>
    RustLib.instance.api.crateApiSourceRagGetAllChunkIdsAndContents();

/// Update embedding for a single chunk.
Future<void> updateChunkEmbedding({
  required PlatformInt64 chunkId,
  required List<double> embedding,
}) => RustLib.instance.api.crateApiSourceRagUpdateChunkEmbedding(
  chunkId: chunkId,
  embedding: embedding,
);

class AddSourceResult {
  final PlatformInt64 sourceId;
  final bool isDuplicate;
  final int chunkCount;
  final String message;

  const AddSourceResult({
    required this.sourceId,
    required this.isDuplicate,
    required this.chunkCount,
    required this.message,
  });

  @override
  int get hashCode =>
      sourceId.hashCode ^
      isDuplicate.hashCode ^
      chunkCount.hashCode ^
      message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddSourceResult &&
          runtimeType == other.runtimeType &&
          sourceId == other.sourceId &&
          isDuplicate == other.isDuplicate &&
          chunkCount == other.chunkCount &&
          message == other.message;
}

class ChunkData {
  final String content;
  final int chunkIndex;
  final int startPos;
  final int endPos;
  final String chunkType;
  final Float32List embedding;

  const ChunkData({
    required this.content,
    required this.chunkIndex,
    required this.startPos,
    required this.endPos,
    required this.chunkType,
    required this.embedding,
  });

  @override
  int get hashCode =>
      content.hashCode ^
      chunkIndex.hashCode ^
      startPos.hashCode ^
      endPos.hashCode ^
      chunkType.hashCode ^
      embedding.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChunkData &&
          runtimeType == other.runtimeType &&
          content == other.content &&
          chunkIndex == other.chunkIndex &&
          startPos == other.startPos &&
          endPos == other.endPos &&
          chunkType == other.chunkType &&
          embedding == other.embedding;
}

class ChunkForReembedding {
  final PlatformInt64 chunkId;
  final String content;

  const ChunkForReembedding({required this.chunkId, required this.content});

  @override
  int get hashCode => chunkId.hashCode ^ content.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChunkForReembedding &&
          runtimeType == other.runtimeType &&
          chunkId == other.chunkId &&
          content == other.content;
}

class ChunkSearchResult {
  final PlatformInt64 chunkId;
  final PlatformInt64 sourceId;
  final int chunkIndex;
  final String content;
  final String chunkType;
  final double similarity;
  final String? metadata;

  const ChunkSearchResult({
    required this.chunkId,
    required this.sourceId,
    required this.chunkIndex,
    required this.content,
    required this.chunkType,
    required this.similarity,
    this.metadata,
  });

  @override
  int get hashCode =>
      chunkId.hashCode ^
      sourceId.hashCode ^
      chunkIndex.hashCode ^
      content.hashCode ^
      chunkType.hashCode ^
      similarity.hashCode ^
      metadata.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChunkSearchResult &&
          runtimeType == other.runtimeType &&
          chunkId == other.chunkId &&
          sourceId == other.sourceId &&
          chunkIndex == other.chunkIndex &&
          content == other.content &&
          chunkType == other.chunkType &&
          similarity == other.similarity &&
          metadata == other.metadata;
}

class SourceEntry {
  final PlatformInt64 id;
  final String? name;
  final PlatformInt64 createdAt;
  final String? metadata;
  final String? status;

  const SourceEntry({
    required this.id,
    this.name,
    required this.createdAt,
    this.metadata,
    this.status,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      createdAt.hashCode ^
      metadata.hashCode ^
      status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SourceEntry &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          createdAt == other.createdAt &&
          metadata == other.metadata &&
          status == other.status;
}

class SourceStats {
  final PlatformInt64 sourceCount;
  final PlatformInt64 chunkCount;

  const SourceStats({required this.sourceCount, required this.chunkCount});

  @override
  int get hashCode => sourceCount.hashCode ^ chunkCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SourceStats &&
          runtimeType == other.runtimeType &&
          sourceCount == other.sourceCount &&
          chunkCount == other.chunkCount;
}
